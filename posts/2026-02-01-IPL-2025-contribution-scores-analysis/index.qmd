---
title: IPL 2025 Contribution Score Analysis
date: "2026-02-01"
categories: [cricket, data science, r]
image: thumbnail.jpg
---

In a [previous blog post](https://bfern.github.io/posts/2023-05-17-introducing-contribution-score/), I have introduced the metric *contribution score*, which looks at the game situation, opposition player and venue and tells you how well a player has performed for each delivery of a match. This allows you to compare performances between batters and bowlers, and understand the impact of wickets compared with run prevention. I have calculated the contribution score for deliveries in the 2025 IPL season, and in this post I will provide some basic analysis of these values. If you'd like to compare this to the standard metrics, then you can see the top run scorers [here](https://www.espncricinfo.com/records/tournament/batting-most-runs-career/indian-premier-league-2025-16622) and the top wicket takers [here](https://www.espncricinfo.com/records/tournament/bowling-most-wickets-career/indian-premier-league-2025-16622). Be aware that my statistics for averages may appear to misalign for a couple of reasons:

* I remove matches which were abandoned or rain affected because I cannot calculate contribution scores for these matches.
* Batting averages are calculated using only dismissals attributed to the bowler (so doesn't include run outs), not all dismissals.

```{r}
#| label: setup
#| include: false
library(readr)
library(dplyr)
library(yaml)
library(DBI)
library(RPostgres)
library(DT)

config <- read_yaml(file.path(path.expand("~"), ".config", "config.yaml"))
con <- dbConnect(
  RPostgres::Postgres(),
  dbname = "cricket",
  host = config$cricketdb$host,
  port = 5432,
  user = config$cricketdb$user,
  password = config$cricketdb$password
)

balls_df <- dbGetQuery(
  con,
  "
  select
    b.matchid,
    b.inningsid,
    b.overid,
    b.deliveryid,
    b.striker,
    b.bowler,
    b.extras_type,
    b.runs,
    b.extras,
    EXISTS (
      SELECT 1
      FROM staging.wickets w
      WHERE w.matchid = b.matchid
        AND w.inningsid = b.inningsid
        AND w.overid = b.overid
        AND w.deliveryid = b.deliveryid
        AND w.dismissal_type IN (
            'caught',
            'bowled',
            'caught and bowled',
            'stumped',
            'lbw',
            'hit wicket'
        )
    ) AS dismissed,
    ((overid > overid_ppstart) or ( (overid = overid_ppstart) and (deliveryid >= deliveryid_ppstart) ) ) and ( (overid < overid_ppend) or ( (overid = overid_ppend) and (deliveryid <= deliveryid_ppend) ) ) as powerplay,
    m.target_overs as innings_overs
  from
    staging.balls b
  left join
    staging.matches m
  on
    b.matchid = m.matchid
  left join
  	staging.powerplays p
  on
  	(b.matchid = p.matchid) and
  	(b.inningsid = p.inningsid)
  where
    (m.comp = 'IPL') and
    (b.inningsid in (1, 2)) and
    (m.date >= '2025-03-22') and
    (m.date <= '2025-06-03') and
    (m.completed_match) and
    (not m.rain_affected)
  ;
"
)
dbDisconnect(con)

batting_contributions <- read_csv(file.path(
  "data",
  "ipl25_batting_contributions.csv"
))
batting_contributions_df <- balls_df |>
  left_join(
    batting_contributions,
    by = c("matchid", "inningsid", "overid", "deliveryid")
  ) |>
  filter(extras_type != "wide")

bowling_contributions <- read_csv(file.path(
  "data",
  "ipl25_bowling_contributions.csv"
))
bowling_contributions_df <- balls_df |>
  left_join(
    bowling_contributions,
    by = c("matchid", "inningsid", "overid", "deliveryid")
  ) |>
  mutate(contr = if_else(extras_type == "wide", extras, contr))
```

I will produce tables for both batting and bowling contributions, across all phases of the match and then split by powerplay, middle overs and death. These tables are all interactive - you can sort the columns by simply clicking on the column name.

### Batting

We will start off with an interactive summary of the contribution scores per batter over all game situations. I have filtered to at least 100 balls faced by the batter.

```{r}
#| label: batting overall
#| echo: false
batting_contributions_df |>
  group_by(striker) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = n(),
    total_runs = sum(runs),
    ave = sum(runs) / sum(dismissed),
    sr = (sum(runs) / n()) * 100,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(desc(total_contr)) |>
  filter(num_balls >= 100) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Runs",
      "Ave",
      "SR",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("sr", 0) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

Lets now break this down into different phases of the game:

* powerplay
* middle overs (overs 7-15)
* death (overs 16-20).

Each of these tables is filtered to at least 50 balls faced by the batter.

**Powerplay**

```{r}
#| label: batting powerplay
#| echo: false
batting_contributions_df |>
  filter(powerplay) |>
  group_by(striker) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = n(),
    total_runs = sum(runs),
    ave = sum(runs) / sum(dismissed),
    sr = (sum(runs) / n()) * 100,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(desc(total_contr)) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Runs",
      "Ave",
      "SR",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("sr", 0) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

**Middle Overs**

```{r}
#| label: batting middle overs
#| echo: false
batting_contributions_df |>
  filter(!powerplay, overid < innings_overs - 5) |>
  group_by(striker) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = n(),
    total_runs = sum(runs),
    ave = sum(runs) / sum(dismissed),
    sr = (sum(runs) / n()) * 100,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(desc(total_contr)) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Runs",
      "Ave",
      "SR",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("sr", 0) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

**Death**

```{r}
#| label: batting death
#| echo: false
batting_contributions_df |>
  filter(!powerplay, overid >= innings_overs - 5) |>
  group_by(striker) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = n(),
    total_runs = sum(runs),
    ave = sum(runs) / sum(dismissed),
    sr = (sum(runs) / n()) * 100,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(desc(total_contr)) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Runs",
      "Ave",
      "SR",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("sr", 0) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

### Bowling

Lets now see the same tables for bowlers, starting with all phases of the game. A minimum of 100 balls bowled per bowler is required.

```{r}
#| label: bowling overall
#| echo: false
bowling_contributions_df |>
  group_by(bowler) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = sum(!extras_type %in% c("wide", "noball")),
    total_wickets = sum(dismissed),
    ave = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(dismissed),
    er = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(!extras_type %in% c("wide", "noball")) *
      6,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(total_contr) |>
  filter(num_balls >= 100) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Wickets",
      "Ave",
      "Econ",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("er", 2) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

We will break this down into the three different phases of the game again, filtering to at least 50 balls bowled for a bowler.

**Powerplay**

```{r}
#| label: bowling powerplay
#| echo: false
bowling_contributions_df |>
  filter(powerplay) |>
  group_by(bowler) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = sum(!extras_type %in% c("wide", "noball")),
    total_wickets = sum(dismissed),
    ave = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(dismissed),
    er = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(!extras_type %in% c("wide", "noball")) *
      6,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(total_contr) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Wickets",
      "Ave",
      "Econ",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("er", 2) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

**Middle Overs**

```{r}
#| label: bowling middle overs
#| echo: false
bowling_contributions_df |>
  filter(!powerplay, overid < innings_overs - 5) |>
  group_by(bowler) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = sum(!extras_type %in% c("wide", "noball")),
    total_wickets = sum(dismissed),
    ave = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(dismissed),
    er = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(!extras_type %in% c("wide", "noball")) *
      6,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(total_contr) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Wickets",
      "Ave",
      "Econ",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("er", 2) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```

**Death**

```{r}
#| label: bowling death
#| echo: false
bowling_contributions_df |>
  filter(!powerplay, overid >= innings_overs - 5) |>
  group_by(bowler) |>
  summarise(
    num_innings = length(unique(matchid)),
    num_balls = sum(!extras_type %in% c("wide", "noball")),
    total_wickets = sum(dismissed),
    ave = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(dismissed),
    er = sum(
      runs + if_else(extras_type %in% c("wide", "noball"), extras, 0)
    ) /
      sum(!extras_type %in% c("wide", "noball")) *
      6,
    total_contr = sum(contr),
    .groups = "drop"
  ) |>
  mutate(
    mean_contr_per_innings = total_contr / num_innings,
    mean_contr_per_ball = total_contr / num_balls
  ) |>
  arrange(total_contr) |>
  filter(num_balls >= 50) |>
  DT::datatable(
    rownames = FALSE,
    class = "stripe hover compact",
    colnames = c(
      "Name",
      "Inns",
      "Balls",
      "Wickets",
      "Ave",
      "Econ",
      "Total Contr",
      "Contr Per Inns",
      "Contr Per Ball"
    ),
    options = list(
      pageLength = 10,
      dom = "lftip",
      scrollX = TRUE
    )
  ) |>
  formatRound("ave", 1) |>
  formatRound("er", 2) |>
  formatRound("total_contr", 0) |>
  formatRound("mean_contr_per_innings", 2) |>
  formatRound("mean_contr_per_ball", 3)
```