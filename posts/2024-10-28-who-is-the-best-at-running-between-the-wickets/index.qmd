---
title: Who is the best at running between the wickets?
date: "2024-11-13"
categories: [cricket, data science, r, visualisation]
---

Note to self: see ~/Downloads/rough.R for code that I have written so far.

Over the past few months, I've taken an interest in baseball analytics because there is so much cricket can learn from what has been done there. I've learnt that base running is a large component of the game, which struck me as odd since running between the wickets is neglected in cricket. But should it be? In this post, I will quantify the effect that a strong runner between the wickets has upon the team.

To do this, I am going to use wagonwheel data of where a batter hits the ball and how many runs they end up scoring. I will then build a model that predicts the number of runs they are expected to score, and we can then compare these predictions to the actual runs scored for different batters.

Firstly, lets take a look at the dataset that I am using. I am using ball by ball data that has been put together by [Himanish Ganjoo](https://twitter.com/hganjoo_153). The dataset that I am using has been filtered so that it contains only the following:

* T20 Blast from 2015 to 2024 (to limit the size of the dataset but still have plenty of data for each player)
* Matches played at the 18 major England and Wales stadiums (because some of the outgrounds that get used can have unusual dimensions)
* Balls from outside the powerplay (because this causes the distribution of runs to vary significantly)
* Balls that did not go for a boundary
* Balls with wagonwheel data (I'm assuming that these are only deliveries where the batter hit the ball)

```{r}
source("data.R")
```
Lets take a look at this wagonwheel data, using different colours to denote the number of runs ran.

## plot wagonwheel data with colours of runs ran

## some comments about this graph

Lets now think about building the model. I should include the following variables in the model:
* wagonX and wagonY (obviously)
* ground (grounds can vary in size, which means that smaller grounds will have less twos)
* bowl_kind (since I don't have fielding data, this helps give a proxy of where the fielders are positioned)
* bat_hand (this also helps gives a proxy of what the field is like)
* innings_balls_remaining (towards the later stages of a game, batters will take more risks)

I will use a random forest model, using the [randomForest](https://cran.r-project.org/web/packages/randomForest/index.html) package in R. You can see the full code for training the model from the data on my [GitHub](LINK TO MODEL TRAINING)

```{r}
library(randomForest)
 
rf_model <- randomForest(
  score_minus_wides_and_noballs ~ 1 +
    wagonX +
    wagonY +
    ground +
    bowl_kind +
    bat_hand +
    balls_rem,
  data = t20_bbb,
  ntree = 100,
  mtry = 3,
  nodesize = 20,
  importance = TRUE
)
```

```{r}
# Load necessary libraries
library(randomForest)
library(doParallel)
library(foreach)

df <- t20_bbb

# Ensure the categorical variables are factors
df$ground <- as.factor(df$ground)
df$bowl_kind <- as.factor(df$bowl_kind)
df$bat_hand <- as.factor(df$bat_hand)

# Set up parallel backend
num_cores <- detectCores() - 1  # Use all but one core
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Define grid search parameters
nodesizes <- c(3, 5, 10, 20, 30)
mtry_value <- 3

# Perform grid search
set.seed(42)  # For reproducibility
grid_results <- foreach(nodesize = nodesizes, .combine = rbind, .packages = 'randomForest') %dopar% {
  rf_model <- randomForest(
    formula = score_minus_wides_and_noballs ~ wagonX + wagonY + ground + bowl_kind + bat_hand + balls_rem,
    data = df,
    ntree = 100,       # Number of trees
    mtry = mtry_value, # Fixed mtry value
    nodesize = nodesize, # Vary nodesize
    importance = FALSE # No need to calculate variable importance during grid search
  )
  
  # Capture OOB error for this setting
  data.frame(nodesize = nodesize, oob_error = rf_model$mse[length(rf_model$mse)])
}

# Stop the parallel backend
stopCluster(cl)

# View grid search results
print(grid_results)
```

```{r}
unique_points <- t20_bbb %>%
  #filter(ground == "Edgbaston, Birmingham") %>%
  distinct(wagonX, wagonY, bowl_kind, bat_hand, ground, balls_rem) #%>%
  #mutate(ground = "Edgbaston, Birmingham")

unique_points$predictions <- predict(rf_model, newdata = unique_points)

ggplot(unique_points, aes(x = -wagonX, y = wagonY, fill = predictions)) +
  geom_tile(color = "white") +  # Add a white border to the tiles for better visibility
  facet_grid(bowl_kind ~ bat_hand) + 
  scale_fill_gradientn(
    #colors = c("red", "blue"),,
    values = scales::rescale(c(0,3)),
    #colors = c("red", "orange", "blue", "lightblue"),
    colors = c("#FF0000", "orange", "blue", "#00FFFF"),  # Define the colors
                       #values = scales::rescale(c(0, 1, 2, 3)),  # Rescale values
                       limits = c(0, 3), 
                       name = "Prediction") + 
  labs(#title = "Predictions by -wagonX and wagonY for Ground: Edgbaston, Birmingham",
       x = NULL, y = NULL) +  # Remove axis labels
  theme_minimal() +
  theme(panel.spacing = unit(2, "lines")) +  # Increase spacing between facets
  geom_point(size = 4, shape = 21, color = "black", alpha = 0.7) +  # Add points with fixed size
  scale_size_continuous(range = c(4, 4)) +  # Set all points to the same size
  theme(axis.text.x = element_blank(),   # Remove x-axis text
        axis.ticks.x = element_blank(),  # Remove x-axis ticks
        axis.text.y = element_blank(),   # Remove y-axis text
        axis.ticks.y = element_blank())   # Remove y-axis ticks
```


I now want to check that this model is giving us sensible predictions. Lets take a look at its predictions for deliveries at Edgbaston in our dataset.

## model prediction and graphing the output at edgbaston, add label to graph so people know where the bowlers end is

To be perfectly honest, I wasn't expecting the model to come out as good as this. The graphs make a lot of intuitive sense to anyone who knows T20 cricket for a variety of reasons:
* You can make out where the boundary fielders usually are, particuarly for the spinners - three on the leg side and two on the off.
* You can also make out fielding positions that are almost always on the edge of the ring - for example backward point and extra cover.
* The deep third man/deep fine leg positions score a lot more highly for spin compared to pace - there very rarely is a fielder on the boundary behind square for spinners.

So, given that we're happy with the model, lets see the results! Which batters score a lot more runs than expected? Lets take a look...

## top run scorers and some commentary about it

What about those who do a lot worse than expected

## bottom run scorers and some commentary about it

Given our analysis, can we say how many extra runs X contributes to Y? On average, these are the number of non boundary deliveries that each position is in for (so including both on strike and at the bowlers end) during a T20 match:

So if we were choosing between X and Y for position Z in the team, X is expected to contribute W extra runs to the team score because of his running ability.

Whilst we have quantified the number of runs that each batter will directly contribute through their running ability, there are also indirect effects of running ability that haven't been quantified: a batter can feel pressure if they are struggling to rotate the strike leading to them and potentially their partner too being more likely to lose their wicket on a future delivery. Also from my experience of watching cricket, a team are more likely to be let down if one batter is slow rather than being  being benefitted from one batter being fast - the time it takes to complete a run will only be as quick as the slowest of the two runners.
